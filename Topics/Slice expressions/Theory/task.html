<h2>Slice expressions</h2>
<html><body><p>Go provides the ability to access individual elements of arrays and slices by using indices. It is possible because these types are considered <strong>ordered sequences</strong>.</p>
<p>Apart from being accessing specific elements of a slice, it is also possible to perform other index-based operations with slices. In this topic, you'll learn how to work with <strong>slice expressions</strong> to perform such operations.</p>
<h5 id="simple-slice-expressions">Simple slice expressions</h5>
<p>In Go, we can use slice expressions to perform a series of operations. Let's first take a look at the syntax of a <strong>simple slice expression</strong>, which is commonly used to construct a <strong>subslice</strong>:</p>
<pre><code class="language-go">s[low:high]</code></pre>
<p>The range indexes <code class="language-go">low</code> and <code class="language-go">high</code> select which elements of the <code class="language-go">s</code> slice will appear in the result. Now let's go ahead and take a look at the syntax to create the <code class="language-go">s1</code> subslice:</p>
<pre><code class="language-go">s := []int{2, 3, 5, 7, 11} // len: 5 cap: 5
s1 := s[1:3]
fmt.Println(s1) // [3 5]</code></pre>
<p> </p>
<p>Take notice that even though the slice element <code class="language-go">s[1] = 3</code> at range index <code class="language-go">low</code> is included within the new subslice <code class="language-go">s1</code>, the element <code class="language-go">s[3] = 7</code> at range index <code class="language-go">high</code> is not included. In simple terms, <code class="language-go">high</code> serves as range boundary for slice elements.</p>
<p> </p>
<p>The newly created subslice <code class="language-go">s1</code> has the length <code class="language-go">len</code> equal to the indexes range <code class="language-go">high-low -&gt; 3-1 = 2</code> and capacity <code class="language-go">cap</code> equal to <code class="language-go">cap(s)-low -&gt; 5-1 = 4</code>:</p>
<pre><code class="language-go">fmt.Println("len:", len(s1), "cap:", cap(s1)) // len: 2 cap: 4</code></pre>
<p>For convenience, we can omit any of the range indexes. A missing <code class="language-go">low</code> index defaults to zero, and a missing <code class="language-go">high</code> index defaults to the total length of the slice:</p>
<pre><code class="language-go">fmt.Println(s[2:]) // [5 7 11]     — same as s[2:len(s)]
fmt.Println(s[:3]) // [2 3 5]      — same as s[0:3]
fmt.Println(s[:])  // [2 3 5 7 11] — same as s[0:len(s)]</code></pre>
<p>Since <code class="language-go">strings</code> are just sequences of characters, we can use the same syntax we utilize to get a subslice to construct a <strong>substring</strong>:</p>
<pre><code class="language-go">star := "Polaris"
s2 := star[0:5] + " Bear"
fmt.Println(s2) // Polar Bear

planets := []string{"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"}
s3 := planets[5][0:5] + "day"
fmt.Println(s3) // Saturday</code></pre>
<h5 id="details-of-simple-slice-expressions">Details of simple slice expressions</h5>
<p>When writing a simple slice expression to get a subslice from an array or a <code class="language-go">string</code>, the <code class="language-go">low</code> and <code class="language-go">high</code> indexes are valid if they are in range: <code class="language-go">0 &lt;= low &lt;= high &lt;= len(s)</code>, otherwise, they are out of range, and you'll get a runtime error. For example:</p>
<pre><code class="language-go">star := "Polaris"
fmt.Println(star[-1])  // invalid argument: index -1
fmt.Println(star[0:8]) // runtime error: slice bounds out of range [:8] with length 7</code></pre>
<p>However, for slices, the upper index bound or <code class="language-go">high</code> is the slice capacity <code class="language-go">cap</code>, rather than its length <code class="language-go">len</code>:</p>
<pre><code class="language-go">teams := []string{"Bayern Münich", "Real Madrid", "Manchester City"}
t := teams[1:2]
fmt.Println(t, "| len:", len(t), "cap:", cap(t)) // [Real Madrid] | len: 1 cap: 2
fmt.Println(t[1:3]) // runtime error: slice bounds out of range [:3] with capacity 2</code></pre>
<p>Simple slice expressions support arrays, slices, strings, and pointers to array/slice as well:</p>
<pre><code class="language-go">consts := new([3]float64)
*consts = [3]float64{3.1416, 2.718, 1.618} // pointer to an array
fmt.Println(consts[1:3])                   // [2.718 1.618]

animals := new([]string)
*animals = []string{"cat", "dog", "fish"} // pointer to a slice
fmt.Println((*animals)[1:3])              // ["dog" "fish"]</code></pre>
<p> </p>
<p>When slicing a pointer to an array, we can simply use the regular <code class="language-go">s[low:high]</code> syntax. However, when slicing a pointer to a slice, we need to use the <code class="language-go">(*s)[low:high]</code> syntax.</p>
<p> </p>
<p>Finally, if we try to get the subslice of a <code class="language-go">nil</code> slice, the result will also be a <code class="language-go">nil</code> slice:</p>
<pre><code class="language-go">var n []int       // nil slice
fmt.Println(n[:]) // []</code></pre>
<h5 id="getting-the-subslice-of-a-subslice">Getting the subslice of a subslice</h5>
<p>An important detail is that subslices share a common underlying array with their "parent slice". To further explain the common underlying array concept, let's see what happens if we try to get the subslice of a subslice:</p>
<pre><code class="language-go">var nums [5]int
nums = [5]int{1, 2, 3, 4, 5}
n1 := nums[0:4] // underlying array of n1 is array nums - n1[2] == nums[2]
n2 := n1[0:3]   // underlying array of n2 is array n1 - n2[2] == n1[2]
n2[2] = 343     // n2[2] == n1[2] == nums[2] - refer to the same underlying array element</code></pre>
<p>The subslice <code class="language-go">n1</code> has <code class="language-go">nums</code> as its underlying array, while the underlying array of the subslice <code class="language-go">n2</code> is <code class="language-go">n1</code>. This means that <code class="language-go">n2</code> has a part of <code class="language-go">nums</code> as its underlying array too, therefore the <code class="language-go">n2[2] = 343</code> assignment updates all three of them:</p>
<pre><code class="language-go">fmt.Println(nums) // [1 2 343 4 5]
fmt.Println(n1)   // [1 2 343 4]
fmt.Println(n2)   // [1 2 343]</code></pre>
<h5 id="full-slice-expressions">Full slice expressions</h5>
<p>The key difference between simple slice expressions and a <strong>full slice expressions</strong> is that the latter have one additional range index <code class="language-go">max</code>:</p>
<pre><code class="language-go">s[low:high:max]</code></pre>
<p>The above syntax constructs a subslice of the same type and with the same length as the simple slice expression <code class="language-go">s[low:high]</code>. Now let's write the first full slice expression:</p>
<pre><code class="language-go">s := []int{2, 3, 5, 7, 11}
s4 := s[1:3:4]
fmt.Println(s4, "| len:", len(s4), "cap:", cap(s4)) // [3 5] | len: 2 cap: 3</code></pre>
<p>Just like simple slice expressions, the resulting subslice <code class="language-go">len</code> is equal to <code class="language-go">high-low</code>, however, the capacity <code class="language-go">cap</code> is equal to <code class="language-go">max-low -&gt; 4-1 = 3</code>.</p>
<p></p><div class="alert alert-primary">Full slice expressions are restricted to array, slice, or pointer to array/slice types only! If you tried to use a full slice expression on a <code class="language-go">string</code> type, you would get the following error:

<pre><code class="language-go">star := "Polaris"
fmt.Println(star[1:3:2]) // invalid operation: 3-index slice of string</code></pre>
<p></p></div>
<h5 id="details-of-full-slice-expressions">Details of full slice expressions</h5>
<p>The index range for full slice expressions is different from simple slice expressions. The indexes are valid if they are in range: <code class="language-go">0 &lt;= low &lt;= high &lt;= max &lt;= cap(s)</code>, otherwise, they are out of range:</p>
<pre><code class="language-go">s := []int{2, 3, 5, 7, 11}
fmt.Println(s[1:3:2]) // invalid slice indices: 2 &lt; 3
fmt.Println(s[1:3:6]) // runtime error: slice bounds out of range [::6] with capacity 5</code></pre>
<p>In full slice expressions only the <code class="language-go">low</code> index is optional, it defaults to zero in case we omit it:</p>
<pre><code class="language-go">fmt.Println(s[:3:5]) // [2 3 5]</code></pre>
<p>In turn, omitting the <code class="language-go">high</code> or <code class="language-go">max</code> index isn't allowed:</p>
<pre><code class="language-go">fmt.Println(s[1::5]) // middle index required in 3-index slice
fmt.Println(s[1:3:]) // final index required in 3-index slice </code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic, you've learned about slice expressions in Go. In particular, you've covered the following theory:</p>
<ul>
<li>What simple slice expressions are and what range indexes they use (<code class="language-go">low</code> and <code class="language-go">high</code>);</li>
<li>How to get a subslice and a substring with simple slice expressions;</li>
<li>That subslices share a common underlying array with their "parent slice";</li>
<li>What full slice expressions are and what range indexes they use  (<code class="language-go">low</code>, <code class="language-go">high</code>, and <code class="language-go">max</code>);</li>
<li>That full slice expressions do not support strings, they are restricted to slices, arrays, or pointers to slices/arrays.</li>
</ul>
<p>Now it's time to test your knowledge of slice expressions by solving some theory and coding tasks. Let's go!</p></body></html>
